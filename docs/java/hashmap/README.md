# HashMap

> 什么是Hash：Hash也称散列、哈希、对应的英文都是Hash。基本原理就是把任意长度的输入，通过Hash算法变成固定长度的输出。这个映射规则就是对应的Hash算法，而原始数据映射后的二进制串就是哈希值

**Hash的特点：**

1. 从Hash值不可以反向推导出原始的数据
2. 输入数据的微小变化会得到完全不同的Hash值，相同的数据会得到相同的值
3. 哈希算法的执行效率要高效，长的文本也能快速计算出哈希值
4. hash算法的冲突概率要小

由于hash的原理是将输入空间的值映射成hash空间内，而hash值得空间远小于输入的空间。根据出题原理，一定会存在不同的输入被映射成相同输出的情况。

> 抽屉原理：桌子上有十个苹果，要把十个苹果放到九个抽屉中，无论怎么放，我们会发现至少会有一个抽屉里面放不少于两个苹果。这一现象就是我们所说的抽屉原理

**一致性Hash：**

​	

HashMap的底层结构是 **数组+链表+红黑树**

路由寻址公式：（table.length-1）&node.hash    

(16-1)&1122 => B0000 0000 1111 & B0100 0110 0010 => B0010 => 2

**JDK1.8为什么引入红黑树？**

解决hash碰撞导致链化非常严重，查找效率低下O(1)=>O(N)，提高查找效率

红黑树：自平衡的二叉查找树

**HashMap的扩容原理**

## 红黑树的性质

- 性质一：每个节点要么是黑色，要么是红色
- 性质二：根节点是黑色
- 性质三：每个叶子节点（NIL）是黑色
- 性质四：每个红色节点的两个子节点一定都是黑色
- 性质五：任意一节点到每个叶子节点的路径都包含数量相同的黑节点。俗称：黑高
- 从性植五可以推出：如果一个节点存在黑子节点，那么该节点肯定有两个子节点

>红黑树插入后修复红黑树平衡的方法
>
>​	|---情景1：红黑树为空
>
>​	|---情景2：插入节点的key已经存在
>
>​	|---情景3：插入节点的父节点为黑色
>
>​	|---情景4：插入的节点的父节点为红色**(需要处理的情况)**
>
>​			|---情景4.1：叔叔节点存在，并且为红色（父-叔 双红）
>
>​			|---情景4.2：叔叔节点不存在，或者为黑色，父节点为爷爷节点的左子树
>
>​				|---情景4.2.1：插入节点为其父节点的左子节点（LL情况）
>
>​				|---情景4.2.2：插入节点为其父节点的右子节点（LR情况）
>
>​			|---情景4.3：叔叔节点不存在，或者为黑色，父节点为爷爷节点的右子树
>
>​				|---情景4.3.1：插入节点为其父节点的右子节点（RR情况）
>
>​				|---情景4.2.2：插入节点为其父节点的左子节点（RL情况）
>
>​		